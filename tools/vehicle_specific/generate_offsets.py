
import sys
import os
import re
from shapely.geometry import Polygon

def parse_svg_path_points(svg_path):
    with open(svg_path, 'r') as f:
        content = f.read()
    
    # Robust parsing using re for "M x,y L x,y ..."
    # This assumes simple polygon paths as generated by refine_trace.py
    match = re.search(r'd="([^"]+)"', content)
    if not match:
        raise ValueError("Could not find path data in SVG")
    
    d_str = match.group(1)
    parts = re.split(r'[ ,a-zA-Z]+', d_str)
    numbers = [float(p) for p in parts if p.strip()]
    
    points = []
    for i in range(0, len(numbers), 2):
        if i+1 < len(numbers):
            points.append((numbers[i], numbers[i+1]))
            
    return points

def write_svg_offsets(original_points, offsets_mm, output_path):
    # Create Shapely polygon
    poly = Polygon(original_points)
    
    # Calculate bounds for viewBox
    min_x, min_y, max_x, max_y = poly.bounds
    
    # Expand bounds for offsets (Top/Left/Right/Bottom)
    # Bottom offsets are critical for clearance, so we must show them.
    max_offset = 0
    if offsets_mm:
        max_offset = max(offsets_mm)
        
    padding = max_offset + 5 # 5mm padding for stroke width
    
    min_x -= padding
    max_x += padding
    
    # We expand max_y (bottom) to include offsets.
    max_y += padding
    
    # Crop to bottom (User request: "crop 20cm more off", "make original trace red dashed")
    # We keep only the very bottom section.
    trace_bottom = max_y - padding
    crop_height = 15 # 15mm crop
    calculated_min_y = trace_bottom - crop_height # Logical top of crop
    
    min_y = calculated_min_y
    # Ensure min_y isn't greater than max_y (sanity check)
    if min_y >= max_y: min_y = max_y - 10 
    
    width = max_x - min_x
    height = max_y - min_y
    
    svg_header = f"""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg
   width="{width}mm"
   height="{height}mm"
   viewBox="{min_x} {min_y} {width} {height}"
   xmlns="http://www.w3.org/2000/svg">
"""
    
    svg_body = ""
    
    # Draw original trace (red dashed, per user request)
    pts_str = " ".join([f"{x:.4f},{y:.4f}" for x,y in original_points])
    # 1pt is approximately 0.353mm (1/72 inch * 25.4 mm/inch)
    svg_body += f'  <path d="M {pts_str} Z" fill="none" stroke="red" stroke-width="0.353" stroke-dasharray="4,4"/>\n'
    
    # Draw centerline (red dash-dot)
    # X=0 is the center because refine_trace.py centers it.
    svg_body += f'  <line x1="0" y1="{min_y}" x2="0" y2="{max_y}" stroke="red" stroke-width="1" stroke-dasharray="10,4,2,4" />\n'
    
    # Draw offsets (None requested)
    for offset in offsets_mm:
        pass # No offsets
        
    svg_footer = "</svg>"
    
    with open(output_path, 'w') as f:
        f.write(svg_header + svg_body + svg_footer)

def main():
    if len(sys.argv) < 2:
        print("Usage: python generate_offsets.py <input_trace_svg>")
        sys.exit(1)

    input_path = sys.argv[1]
    if not os.path.exists(input_path):
        print(f"Error: File not found {input_path}")
        sys.exit(1)

    # Offsets in mm
    # User said "0 actually"
    offsets = []  
    
    output_path = os.path.join(os.path.dirname(input_path), "offsets.svg")
    
    print(f"Reading {input_path}...")
    points = parse_svg_path_points(input_path)
    
    print(f"Generating offsets: {offsets} mm")
    write_svg_offsets(points, offsets, output_path)
    
    print(f"Saved offsets to {output_path}")

if __name__ == "__main__":
    main()
